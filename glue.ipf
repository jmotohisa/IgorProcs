// Glue two spectra (XY traces, multi_files)// ******************************************//  glue spectra // ******************************************// viewstore "tmpview.vw"// troffMacro glue(wavey1,wavey2,dest,auto)	String wavey1,wavey2,dest="resWave"	Variable auto=1//	Prompt wavex1,"X-wave of spectrum 1",popup,WaveList("*",";","WIN:")	Prompt wavey1,"Y-wave of spectrum 1",popup,WaveList("*",";","WIN:")//	Prompt wavex2,"X-wave of spectrum 2",popup,WaveList("*",";","WIN:")	Prompt wavey2,"Y-wave of spectrum 2",popup,WaveList("*",";","WIN:")	Prompt dest,"Destination wave"	Prompt auto,"auto or manul",popup,"automatic;manual"	PauseUpdate; Silent 1	String wavex1=XWaveName("",wavey1),wavex2=XWaveName("",wavey2)	Variable nb_of_dp1,nb_of_dp2,dp_sum	Variable/D min1,min2,max1,max2	Variable direct,current,collect	Variable/D glue,aver1,aver2,delta	Variable firstdp,lastdp	WaveStats/Q $wavey1	nb_of_dp1 = V_npnts//	min1 = V_min//	max1 = V_max//	left1 = $waveA[0]//	right1 = $waveA[nb_of_dp1-1]	if(strlen(wavex1)==0)		Duplicate/O $wavey1,glue_temp_x1,glue_temp_y1		glue_temp_x1 = x	else		Duplicate/O $wavex1,glue_temp_x1		Duplicate/O $wavey1,glue_temp_y1	Endif		WaveStats/Q $wavey2	nb_of_dp2 = V_npnts//	min2 = V_min//	max2 = V_max//	left2 = $waveB[0]//	right2 = $waveB[nb_of_dp1-1]	if(strlen(wavex2)==0)		Duplicate/O $wavey2,glue_temp_x2,glue_temp_y2		glue_temp_x2 = x	else		Duplicate/O $wavex2,glue_temp_x2		Duplicate/O $wavey2,glue_temp_y2	Endif	//810     waiton//        see//        count_area = 0//        onerror -1//        kill $file_name3//        onerror 1520//       loadspc $file_name1//       area_nb1 = nsubs(#s)//       nb_of_dp1 = npts(#s)//       left1 = getffp()//        right1 = getflp()//        min1 = min(#s.y)//        max1 = max(#s.y)//        noshow//        loadspc $file_name2//        area_nb2 = nsubs(#s)//        nb_of_dp2 = npts(#s)//        left2 = getffp()//        right2 = getflp()//        min2 = min(#s.y)//        max2 = max(#s.y)//        noshow//        onerror 1510//	if (area_nb1 != area_nb2)//		Abort990()//	endif//	area_nb = area_nb1 //	if(left1<=left2)//		left = left1//	else//		left = left2//	endif//	if(right1<=right2)//		right = right2//	else//		right = right1//	endif//	if(min1<=min2)//		miny = min1//	else//		miny = min2//	endif//	if(max1<=max2)//		maxy = max2//	else//		maxy = max1//	endif//	if(mc = 1) then gosub 1000 // currently, does not support manual gluing// autogluing	direct = direction(nb_of_dp1,nb_of_dp2)		// 815     gosub 1500	if((!((direct == 0) %& (glue_temp_x1[nb_of_dp1-1] > glue_temp_x2[0]))) %& (!((direct == 1) %& (glue_temp_x1[nb_of_dp1-1] < glue_temp_x2[0]))))		Abort990()	endif//        if ((direct == 0) %& (rightx($waveA) > leftx($waveB))) then goto 816//        if ((direct == 1) %& (rightx($waveA) < leftx($waveB))) then goto 816//        Abort990()//816     if getsfile() = 0 goto 818//        noshow: goto 816//818	dp_sum = nb_of_dp1 + nb_of_dp2	Make/D/N=(dp_sum)/O glue_temp_x3,glue_temp_y3//        free x3, y3//        dim x3(dp_sum), y3(dp_sum)	current = 0	collect = 0	do		if ((direct == 0) %& (glue_temp_x1[current] >= glue_temp_x2[1]))			break		endif		if ((direct == 1) %& (glue_temp_x1[current] <= glue_temp_x2[1]))			break		endif		glue_temp_x3[collect] = glue_temp_x1[current]		glue_temp_y3[collect] = glue_temp_y1[current]		current += 1 // counter for current spectrum		collect += 1 // counter for result (accumulation)	while(1)//820     if ((direct = 0) and (x1(current) >= x2(1))) then goto 825//        if ((direct = 1) and (x1(current) <= x2(1))) then goto 825//        x3(collect) = x1(current) : y3(collect) = y1(current)//        current = current + 1 ' counter for current spectrum//        collect = collect + 1 ' counter for result (accumulation)//        goto 820	glue = glue_temp_x1[current - 1] + ( glue_temp_x1[nb_of_dp1 - 1] - glue_temp_x1[current - 1])/2 // wl for gluing//825     glue =  x1(current - 1) + ( x1(nb_of_dp1 - 1) - x1(current - 1))/2 ' wl for gluing	do		if ((direct == 0) %& (glue_temp_x1[current] > glue))			break		endif		if ((direct == 1) %& (glue_temp_x1[current] < glue))			break		endif		glue_temp_x3[collect] = glue_temp_x1[current]		glue_temp_y3[collect] = glue_temp_y1[current]		current += 1		collect += 1	while(1)//830     if ((direct = 0) and (x1(current) > glue)) then goto 832//        if ((direct = 1) and (x1(current) < glue)) then goto 832//        x3(collect) = x1(current) : y3(collect) = y1(current)//        current = current + 1//        collect = collect + 1//        goto 830	firstdp = current - 16	lastdp = current - 1//	Print "First data point",firstdp//	Print "Last data point",lastdp//	first = 1	aver1 = function950(firstdp,lastdp)//	print aver1//832     firstdp = current - 16//        lastdp = current - 1//        first = 1//        gosub 950//        aver1 = aver	glue_temp_x1 = glue_temp_x2	glue_temp_y1 = glue_temp_y2	current = 0//835     x1 = x2 : y1 = y2//        current = 0//	Print glue,direct	do//		print direct,current,glue,glue_temp_x1[current]		if ((direct == 0) %& (glue_temp_x1[current] > glue))			break		endif		if ((direct == 1) %& (glue_temp_x1[current] < glue))			break		endif		current += 1	while(1)//840     if ((direct = 0) and (x1(current) > glue)) then goto 844//        if ((direct = 1) and (x1(current) < glue)) then goto 844//        current = current + 1//        goto 840	firstdp = current	lastdp = current + 15//	first = 0//	Print "First data point",firstdp//	Print "Last data point",lastdp	aver2 = function950(firstdp,lastdp)//844     firstdp = current//        lastdp = current + 15//        first = 0//        gosub 950//        aver2 = aver	delta = aver1 - aver2//        delta = aver1 - aver2	glue_temp_y1 = glue_temp_y2	do		glue_temp_x3[collect] = glue_temp_x1[current]		glue_temp_y3[collect] = glue_temp_y1[current] + delta		current += 1		collect += 1	while(current < nb_of_dp2)//845     x3(collect) = x1(current) : y3(collect) = y1(current) + delta//        current = current + 1//        collect = collect + 1//        if (current < nb_of_dp2) then goto 845  '<=	Duplicate/O glue_temp_x3,$(dest + "_x")	Duplicate/O glue_temp_y3,$(dest + "_y")	Edit $(dest + "_x"),$(dest + "_y")	AppendToGraph $(dest + "_y") vs $(dest + "_x")End Macro//        accum_length = collect//        newspc trace(accum_length,128)//        portout -140, 132//        setffp x3(0),x3(accum_length-1)//        #s.x = x3//        #s.y = y3//        setstime i//        setsnext i+1//        string tempx1, -16//        string tempy1, -18//        if (area_nb = 1) then savespc $file_name3//        if ((area_nb > 1) and (i <= area_nb)) then savespc $file_name3,#i//        if (i = area_nb) then savespc $file_name3//850     if getsfile() = 0 goto 855//        noshow: goto 850//855     count_area = count_area + 1//        if (count_area <= area_nb - 1) then goto 815  'next area//        loadspc $file_name3//        area_nb = nsubs(#s)//        if (area_nb = 1) then viewonly "gluesmp.vw"//        if (area_nb > 1) then viewonly "spectr.vw"//        setzbeg 1//        setzend area_nb//        setleft left, right//        setmin miny, maxy//        axes 1//        display//        waitoff//        end//************************************// remove peaks//************************************Function/D function950(firstdp,lastdp)	Variable firstdp,lastdp	Variable/D aver=0,sm=0,std,rm,all	Variable j=0,k		do		aver = 0		k=firstdp		j=0		do			if(k>lastdp)				break			endif			aver += glue_temp_y1[k] 			j += 1			k += 1//			print "loop aver",k		while(1)		aver = aver/j	//        aver = 0: j = 0//        for k = firstdp to lastdp//                aver = aver + y1(k)//                j = j + 1//        next//        aver = aver/j		sm = 0		k=firstdp		do			if(k>lastdp)				break			endif			sm += (glue_temp_y1[k] - aver)^2			k += 1//			print "loop sm",k		while(1)		sm = sm/(j-1)//        sm = 0//        for k = firstdp to lastdp//                sm = sm + squared(y1(k) - aver)//        next//        sm = sm/(j - 1)//	Print aver,sm		std = sqrt(sm)		sm = aver + std		rm = 0//        std = sqrt(sm)//        sm = aver + std: rm = 0		k = firstdp		do			if(k>lastdp)				break			endif			if(glue_temp_y1[k] > sm)				glue_temp_y1[k] = aver				rm +=1//				Print rm//				if ((first == 1) %& (k === lastdp)) then y3(collect - 1) = aver 			endif			k += 1		while(1)//        for k = firstdp to lastdp//                if (y1(k) <= sm) then goto 955//                y1(k) = aver//                rm = rm + 1//'                if ((first = 1) and (k = lastdp)) then y3(collect - 1) = aver //955     next//		print "rm",rm		if(rm==0)			break		endif	while(1)//        if (rm > 0) then goto 950	print "loop exit"	all = j	return aver//        all = j//        return                End Function//*****************************// spectral data mismatch//*****************************Proc Abort990()	Abort "SORRY! The gluing is not possible for these two spectra!"End Proc//990     beep : dialogon "SORRY!"//        print "The gluing is not possible for these two spectra!"//        print " "//        dialogoff//        waitoff//991     if getsfile() = 0 goto 992//        noshow: goto 991//        kill $file_tmp//992     end//        return//***********************************        // can data be glued?//***********************************Function direction(nb_of_dp1,nb_of_dp2)	Variable nb_of_dp1,nb_of_dp2	Variable direct1,direct2,direct//1500    i = count_area + 1//        free x1, x2, y1, y2//        loadspc $file_name1,#i//        free tempx1, tempy1, tempx2, tempy2//        dim tempx1(256), tempy1(256), tempx2(256), tempy2(256)//        string tempx1, -15//        string tempy1, -17//        dim x1(nb_of_dp1), y1(nb_of_dp1)//        x1 = #s.x//        y1 = #s.y//        loadspc $file_name2,#i//        dim x2(nb_of_dp2), y2(nb_of_dp2)//        string tempx2, -15//        string tempy2, -17//        if (tempx1 <> tempx2) then gosub 990//        if (tempy1 <> tempy2) then gosub 990//        x2 = #s.x//        y2 = #s.y	direct1 = 0	direct2 = 0    if(glue_temp_x1[nb_of_dp1] <glue_temp_x1[0])    	direct1 = 1    endif    if(glue_temp_x2[nb_of_dp2] <glue_temp_x2[0])    	direct2 = 1    endif    if (direct1 != direct2)    	Abort "SORRY! The gluing is not possible for these two spectra!"    endif	direct = direct1	return directEnd Function