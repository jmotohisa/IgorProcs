#pragma rtGlobals=1		// Use modern global access method.// Loadpcsmatrix.ipf// by J. Motohisa// load calculated results of pcsmatrix//// requires: "wname","MatrixOperations2", "RefractiveIndex"//		note: MatrixOperations2 requires "JEG Tools" (http://www.his.com/jguyer/)// 2000/11/?? ver 0.01: first version @delft// ... many revisions// 2005/01/08 ver 0.1 : first version based on MeasureDelft// 2010/10/12 ver 0.2 : LoadAndCalcAbs added, Loadpcsmatrix_single was not completed in the previous version but//  it is now completed// 2010/10/14 ver 0.2b : load emission added, x-scale considered// 2010/10/27 ver 0.2b2 : load emission with multiple dipole added// 2010/12/11 ver 0.2b3 : load field added// 2011/03/19 ver 0.2b4 : "MatrixOperations3D.ipf" is merged with "3DMatrixOperations.ipf"//									Gizmo-related procedures are embedded "GizmoXYZSliceProc.ipf"// 2012/03/30 ver 0.3a  : x-wave information added for loading data// 2012/06/01 ver 0.3b  : calculation of Poynting vector and generation fixed, scaling function of EM wave added// 2014/04/07 ver 0.4a  : omega is added for xscale#include "MatrixOperations2"#include "3DMatrixOperations"#include "GizmoXYZSliceProc"#include "RefractiveIndex"#include "wname"#include "StrRpl"// xscale//  1: energy//  2: wavelength//  3: wavelength (nonequal-spacing)//  4: omega (normalized freq)//  5: dipole posision x//  6: dipole position y//  7: dipole orientation theta//  8: dipole orientation phiFunction/S Loadpcsmatrix_sub(fileName,pathName,wvname0,numdat,datpos,xscale)	String filename,pathname,wvname0	Variable numdat,datpos,xscale		String wvName	Variable ref,xmin,xmax,xscale0	String xtmp="x_tmp"		if (strlen(fileName)<=0)		if(CmpStr(IgorInfo(2), "Macintosh") == 0)//			Open /D/R/P=$pathName/T="sGBWTEXT" ref // MacOS			Open /D/R/P=$pathName/T=".DAT" ref // windows		else			Open /D/R/P=$pathName/T=".DAT" ref // windows		endif		fileName= S_fileName		print filename	endif		if(strlen(wvname0)==0)		wvName=wname(fileName)	else		wvName=wvname0	endif	xtmp=wvName+"_x"	// as of pcsmarix-0.3a4	String cmd	if(numdat>1)		FLoadColumnDataToMatrix(wvName,fileName,pathName,datpos,numdat,2)//		sprintf cmd,"LoadColumnDataToMatrix(\"%s\",\"%s\",\"%s\",%d,%d,2)",wvName,fileName,pathName,datpos,numdat//		Execute "LoadColumnDataToMatrix(wvName,fileName,pathName,datpos,numdat,2)"//		Execute cmd	else		FLoadColumnDataToMatrix(wvName,fileName,pathName,datpos,1,2)//		sprintf cmd,"LoadColumnDataToMatrix(\"%s\",\"%s\",\"%s\",%d,1,2)",wvName,fileName,pathName,datpos//		Execute cmd		numdat=DimSize($wvName,0)//		Execute "LoadColumnDataToMatrix(wvname,filename,pathName,datpos,1,2)"	endif// load scale for x	switch(xscale)		case 1:		case 2:			xscale0=xscale			break		case 3:			xscale0=2			break;		case 4:			xscale0=3			break;		case 5:		case 6:		case 7:		case 8:			xscale0=xscale-4			break		default:			xscale0=1			break	endswitch			FLoadColumnDataToMatrix(xtmp,fileName,pathName,xscale0,1,2)//	sprintf cmd,"LoadColumnDataToMatrix(\"%s\",\"%s\",\"%s\",%d,1,2)",xtmp,fileName,pathName,xscale0//	Execute cmd//	Execute "LoadColumnDataToMatrix(xtmp,fileName,pathName,xscale0,1,2)"	Wave xtmpwv=$xtmp	xmin=xtmpwv[0]	xmax=xtmpwv[numpnts(xtmpwv)-1]	switch(xscale)		case 1:			SetScale/I x,xmin,xmax,"eV",$wvName			break		case 2:		case 3:		case 5:		case 6:			SetScale/I x,xmin,xmax,"m",$wvName			break		case 4:			SetScale/I x,xmin,xmax,"",$wvName			break		case 7:		case 8:			SetScale/I x,xmin,xmax,"m",$wvName			break		default:			break	endswitch		if(xscale!=3)		KillWaves xtmpwv	else		Redimension/N=(numdat) xtmpwv		SetScale d 0,0,"m", xtmpwv	endif		return wvNameEndMacro Loadpcsmatrix_single(wvName,fileName,pathName,dataname,xscale,wantToDisp)	String wvname,filename,pathname="home",	Variable dataname=1,wantToDisp=2,xscale=1	Prompt wvname,"wave name to store"	Prompt filename,"file name"	Prompt pathname,"path name"	Prompt dataname,"Choose Data",popup,"reflectivity_all;reflectivity_TE;reflectivity_TM;transmittance_all;transmittance_TE;transmittance_TM"	Prompt xscale,"x-scale",popup,"energy;wavelength;wavelenght(nonequal spacing);omega"	Prompt wantToDisp, "Display graphs?", popup, "No;New;Append;AppendToRight"	Silent 1; PauseUpDate		Variable ref,xmin,xmax,xscale0	String wvname0,xtmp,xtmp0		wvname0=Loadpcsmatrix_sub(fileName,pathName,wvName,1,dataname+3,xscale)		if(wantToDisp>1)		if(wantToDisp==2)			Display /W=(3,41,636,476)		endif		if(xscale!=3)			if(wantToDisp==4)				AppendToGraph/R $wvName			else				AppendToGraph $wvName			endif		else			xtmp=wvname0+"_x"			if(wantToDisp==4)				AppendToGraph/R $wvName vs $xtmp			else				AppendToGraph $wvName vs $xtmp			endif		endif	endifEnd MacroMacro Loadpcsmatrix_matrix(wvName,fileName,pathName,dataname,numdat,xscale,wantToDisp)	String wvname,filename,pathname="home"	Variable dataname=1,wantToDisp=1,numdat=101,xscale=1	Prompt wvname,"wave name to store"	Prompt filename,"file name"	Prompt pathname,"path name"	Prompt dataname,"Choose Data",popup,"reflectivity_all;reflectivity_TE;reflectivity_TM;transmittance_all;transmittance_TE;transmittance_TM"	prompt numdat,"number of data"	Prompt xscale,"x-scale",popup,"energy;wavelength;wavelenght(nonequal spacing);omega"	Prompt wantToDisp, "Display graphs?", popup, "No;New;Append;AppendToRight;DensityPlot;DensityPlotWithLegend;"	Silent 1; PauseUpDate		FLoadpcsmatrix_matrix(wvName,fileName,pathName,dataname,numdat,xscale,wantToDisp)EndFunction FLoadpcsmatrix_matrix(wvName,fileName,pathName,dataname,numdat,xscale,wantToDisp)	String wvname,filename,pathname	Variable dataname,wantToDisp,numdat,xscale		String xtmp,xtmp0,xtmp2,wvname0	wvname0=Loadpcsmatrix_sub(fileName,pathName,wvName,numdat,dataname+3,xscale)	if(xscale==3)		xtmp=wvname0+"_x"	else		xtmp="_none_"	endif	switch (wantToDisp)		case 1:		// do nothing			break		case 2:			MatrixWavePlotFunc(wvName0,1,1,xtmp)			break		case 3:			MatrixWavePlotFunc(wvName0,2,1,xtmp)			break		case 4:			MatrixWavePlotFunc(wvName0,2,2,xtmp)			break		case 5:		case 6:			Display /W=(3,41,636,476)			if(xscale==3)				xtmp2=xtmp+"2"				MakeMeshDataFunc(xtmp,xtmp2)				Wave wxtmp2=$xtmp2//				AppendImage wwvName vs wxtmp2			else				AppendImage wwvName			endif			if(wantToDisp==6)				sprintf cmd,"Execute JEG_AddColorLegend(%s)",wvname0//				JEG_AddColorLegend(wvname)			endif			break		default:	endswitchEnd MacroFunction FLoadpcsmatrix_matrix_emission(wvName,fileName,pathName,dataname,numdat,xscale,wantToDisp)	String wvname,filename,pathname	Variable dataname,wantToDisp,numdat,xscale		String xtmp,xtmp0,xtmp2,wvname0	wvname0=Loadpcsmatrix_sub(fileName,pathName,wvName,numdat,dataname+3,xscale)	if(xscale==3)		xtmp=wvname0+"_x"	else		xtmp="_none_"	endif	switch (wantToDisp)		case 1:		// do nothing			break		case 2:			MatrixWavePlotFunc(wvName0,1,1,xtmp)			break		case 3:			MatrixWavePlotFunc(wvName0,2,1,xtmp)			break		case 4:			MatrixWavePlotFunc(wvName0,2,2,xtmp)			break		case 5:		case 6:			Display /W=(3,41,636,476)			if(xscale==3)				xtmp2=xtmp+"2"				MakeMeshDataFunc(xtmp,xtmp2)				Wave wxtmp2=$xtmp2//				AppendImage wwvName vs wxtmp2			else				AppendImage wwvName			endif			if(wantToDisp==6)				sprintf cmd,"Execute JEG_AddColorLegend(%s)",wvname0//				JEG_AddColorLegend(wvname)			endif			break		default:	endswitchEndMacro Loadpcsmatrix_matrix_emission(wvName,fileName,pathName,dataname,numdat,xscale,wantToDisp)	String wvname,filename,pathname="home",	Variable dataname=1,wantToDisp=1,numdat=101,xscale=1	Prompt wvname,"wave name to store"	Prompt filename,"file name"	Prompt pathname,"path name"	Prompt dataname,"Choose Data",popup,"emission_front_all;emission_front_TE;emission_front_TM;ission_back_all;emission_back_TE;emission_back_TM"	prompt numdat,"number of data"	Prompt xscale,"x-scale",popup,"energy;wavelength;wavelenght(nonequal spacing);omega"	Prompt wantToDisp, "Display graphs?", popup, "No;New;Append;AppendToRight;DensityPlot;DensityPlotWithLegend"	Silent 1; PauseUpDate		FLoadpcsmatrix_matrix_emission(wvName,fileName,pathName,dataname,numdat,xscale,wantToDisp)End Macro// case for multiple dipole calculation//  retrieve_emission_(&e0,&e0_te,&e0_tm,&eN,&eN_te,&eN_tm);//  printf("result-emission-md-%d-%d:\t%le\t%le\t%le\t%le\t%le\t%le\t%le\t%le\t%le\t%le\n",//                 *ip,*numcalc,*rrx,*rry,*theta_e,*phi_e,e0,e0_te,e0_tm,eN,eN_te,eN_tm);Function FLoad_matrix_emission_md(wvName,fileName,pathName,dataname,numdat,xscale,xmin0,xmax0,wantToDisp)	String wvname,filename,pathname	Variable dataname,wantToDisp,numdat,xscale,xmin0,xmax0	String xtmp,xtmp0,xtmp2,wvname0,cmd	wvname0=Loadpcsmatrix_sub(fileName,pathName,wvName,numdat,dataname+4,xscale)	if(xscale==3)		xtmp=wvname0+"_x"	else		xtmp="_none_"	endif	Wave wwvName=$wvName0	if(xscale==1)		SetScale/I x,xmin0,xmax0,"eV",wwvName	endif	if(xscale==2)		SetScale/I x,xmin0,xmax0,"m",wwvName	endif	if(xscale==4)		SetScale/I x,xmin0,xmax0,"",wwvName	endif	switch (wantToDisp)		case 1:		// do nothing			break		case 2:			if(numdat==1)				Display wwvName			else				MatrixWavePlotFunc(wvName0,1,1,xtmp)			endif			break		case 3:			if(numdat==1)				AppendToGraph wwvName			else				MatrixWavePlotFunc(wvName0,2,1,xtmp)			endif			break		case 4:			if(numdat==1)				AppendToGraph/R wwvName			else				MatrixWavePlotFunc(wvName0,2,2,xtmp)			endif			break		case 5:		case 6:			if(numdat>1)				Display /W=(3,41,636,476)				if(xscale==3)					xtmp2=xtmp+"2"					MakeMeshDataFunc(xtmp,xtmp2)					Wave wxtmp2=$xtmp2//					AppendImage wwvName vs wxtmp2				else					AppendImage wwvName				endif				if(wantToDisp==6)					sprintf cmd,"Execute JEG_AddColorLegend(%s)",wvname0//					JEG_AddColorLegend(wvname)				endif			endif			break		default:	endswitchEndMacro Load_matrix_emission_md(wvName,fileName,pathName,dataname,numdat,xscale,xmin0,xmax0,wantToDisp)	String wvname,filename,pathname="home"	Variable dataname=1,wantToDisp=1,numdat=101,xscale=1,xmin0=0,xmax0=1	Prompt wvname,"wave name to store"	Prompt filename,"file name"	Prompt pathname,"path name"	Prompt dataname,"Choose Data",popup,"emission_front_all;emission_front_TE;emission_front_TM;ission_back_all;emission_back_TE;emission_back_TM"	prompt numdat,"number of data"	Prompt xscale,"x-scale",popup,"energy;wavelength;wavelenght(nonequal spacing);omega;pos-x;pos-y;d-theta;d-phi"	Prompt xmin0,"xmin"	Prompt xmax0,"xmax"	Prompt wantToDisp, "Display graphs?", popup, "No;New;Append;AppendToRight;DensityPlot;DensityPlotWithLegend"	Silent 1; PauseUpDate	FLoad_matrix_emission_md(wvName,fileName,pathName,dataname,numdat,xscale,xmin0,xmax0,wantToDisp)End Macro// create dispersion curve from wv1(lambda,theta)Macro Show_Dispersion(wv1,pitch,refindex)	String wv1	Variable pitch=0.4e-6,refindex=sqrt(12)	Silent 1;PauseUpdate		Variable nx,ny,ix,iy	String xwv="xwv_"+wv1,xwv2="xwv2_"+wv1,ywv="ywv_"+wv1,zwv="zwv_"+wv1	String cmd		nx=DimSize($wv1,0)	ny=DimSize($wv1,1)	Duplicate/O $wv1,$xwv,$xwv2,$ywv,$zwv//	$xwv=2*pi/x*sin(y*pi/180)/pitch  // not normalized	$xwv=pitch/x*sin(y*pi/180) // normalized k_parallel	$xwv2=x // wavelength	$ywv=1/x*pitch // normalized omega	Redimension/N=(nx*ny) $xwv,$xwv2,$ywv,$zwv	$xwv=$xwv*refindex//	$xwv=$xwv*n_AlGaAs_sellmeier($xwv2,0) // if reflective index is wavelength dependent		Display /W=(192,44,823,766) $ywv vs $xwv	ModifyGraph mode=3,marker=19	cmd="ModifyGraph zColor("+ywv+")={"+zwv+",0,1,BlueHot}"	Execute cmd	ModifyGraph mode=3,marker=19EndMacro PlotDiffraction(wvbase,wvref,wvth,wvphi,size)	String wvbase,wvref,wvth,wvphi	Variable size	Prompt wvref,"base wave name for plot"	Prompt wvref,"wave for reflectivity"	Prompt wvth,"wave for theta"	Prompt wvphi,"wave for phi"	Prompt size,"plot size"	PauseUpdate;Silent 1		Variable npt=numpnts($wvref),th0=$wvth[0]	String wvth_tmp=wvth+"_tmp"	String rwv,xwv,ywv,zwv,cmd	Duplicate/O $wvth,$wvth_tmp	rwv=wvbase+"_r"	xwv=wvbase+"_x"	ywv=wvbase+"_y"	zwv=wvbase+"_z"	$wvth_tmp-=th0	Make/O/N=(npt) $rwv,$xwv,$ywv,$zwv	$rwv=size*tan($wvth_tmp/180*pi)	$xwv=$rwv*cos($wvphi/180*pi)	$ywv=$rwv*sin($wvphi/180*pi)//	$zwv=log(abs($wvref))	$zwv=$wvref	Display $ywv vs $xwv	cmd="ModifyGraph mode=3,marker=19,zmrkSize("+ywv+")={"+zwv+",0,*,1,10}"	Execute cmd	ModifyGraph height={Aspect,1}EndMacro LoadandCalcAbs(wvbase,pathname,fileName,numdat,xscale,wantToDisp)	String wvbase,fileName,pathname="home"	Variable numdat=1,xscale=1,wantToDisp=1	Prompt xscale,"x-scale",popup,"energy;wavelength;wavelenght(nonequal spacing);omega"	Prompt wantToDisp, "Do you want to display graphs?", popup, "Yes;No"	PauseUpdate; Silent 1		Variable ref	String wlwv		if (strlen(fileName)<=0)		if(CmpStr(IgorInfo(2), "Macintosh") == 0)//			Open /D/R/P=$pathName/T="sGBWTEXT" ref // MacOS			Open /D/R/P=$pathName/T=".DAT" ref // windows		else			Open /D/R/P=$pathName/T=".DAT" ref // windows		endif		fileName= S_fileName		print filename	endif	if(strlen(wvbase)==0)		wvbase=wname(filename)	endif	String refwv=wvbase+"_ref",trnwv=wvbase+"_trn",abswv=wvbase+"_abs"		if(numdat<=1)		Loadpcsmatrix_single(refwv,fileName,pathName,1,xscale,2)		Loadpcsmatrix_single(trnwv,fileName,pathName,4,xscale,2)	else		Loadpcsmatrix_matrix(refwv,fileName,pathName,1,numdat,xscale,2,2)		Loadpcsmatrix_matrix(trnwv,fileName,pathName,4,numdat,xscale,2,2)	endif	Duplicate/O $refwv,$abswv	$abswv=1-$refwv-$trnwv	if(xscale==3)		wlwv=wvbase+"_wl"		Duplicate/O $(refwv+"_x"),$wlwv		if(wantToDisp==1)			Display $refwv vs $wlwv			AppendToGraph $trnwv vs $wlwv			AppendToGraph $abswv vs $wlwv		endif	else		if(wantToDisp==1)			Display $refwv,$trnwv,$abswv		endif	endifEndMacro LoadandCalcAbsAll(pathname,filt1,filt2,numdat,xscale,wantToDisp,storeWName,baseWaveNames)	String pathname="_New Path_",baseWaveNames="baseNamesLoaded"	String filt1="",filt2=".out.TE.dat"	Variable numdat=1,xscale=2,wantToDisp=2,storeWName	Prompt pathname,"Path name"	Prompt filt1,"prefix for file names"	Prompt filt2,"suffix for file names"	Prompt numdat,"number of data"	Prompt xscale,"x-scale",popup,"energy;wavelength;wavelenght(nonequal spacing);omega"	Prompt wantToDisp, "Do you want to display graphs?", popup, "Yes;No"	Prompt storeWname, "Store base wave name ?",popup,"yes;no"	Prompt baseWaveNames,"wave name for store loaded wave base names"	PauseUpdate; Silent 1		String wvbase,fileName,ftype	String filterstring=filt1+"*"+filt2	Variable index=0,index2=0		if(CmpStr(IgorInfo(2), "Macintosh") == 0)//		ftype="TEXT"		ftype=".DAT"	else		ftype=".DAT"	endif		if (CmpStr(pathname, "_New Path_") == 0)		// user selected new path ?		NewPath/O data			// this brings up dialog and creates or overwrites path		pathname = "data"	endif		if(strlen(baseWaveNames)==0)		baseWaveNames="LoadedbaseNames"	endif		if(storeWname==1)		Make/N=1/T $baseWaveNames	endif		do		fileName = IndexedFile($pathName,index,ftype)		if(strlen(fileName)==0)			break		endif		if(stringmatch(fileName,filterstring)==1)			// load wave			wvbase=wname(fileName)				Print "loding file ",filename			LoadandCalcAbs(wvbase,pathname,fileName,numdat,xscale,wantToDisp)			if(storeWname==1)				Redimension/N=(index2+1) $baseWaveNames				$baseWaveNames[index2]=wvbase				index2+=1			endif		endif		index+=1	while(1)EndMacro Loadpcsmatrixfield_all(pathname,fname,datnm,wbname,nlayer,makeCwv,epsload,alphaload,col)	String pathname="_New Path_",fname="pcsmatrix",wbname	Variable datnm=0,nlayer=61,epsload=1,makeCwv,alphaload=2,col=1	Prompt pathname, "Name of path containing text files", popup PathList("*", ";", "")+"_New Path_"	Prompt fname,"file name prefix"	Prompt wbname,"base wave name"	Prompt datnm,"file number"	Prompt nlayer,"number of layers (data in the z-direction)"	Prompt makeCwv,"make complex wave ?",popup,"yes;no"	Prompt epsload,"load epsilon data ?",popup,"yes;no"	Prompt alphaload,"load absorption coeffient data ?",popup,"yes;no"	Prompt col,"column",popup,"y;x"	PauseUpdate;Silent 1		String wname,extn,wre,wim,wc,epswv,alphawv	Variable col2		if (CmpStr(pathname, "_New Path_") == 0)		// user selected new path ?		NewPath/O data			// this brings up dialog and creates or overwrites path		pathname = "data"	endif	if(strlen(wbname)==0)		wbname=strrpl(strrpl(fname,".","_"),"-","_")	endif	if(col==1)		col2=3	else		col2=4	endif		extn="exr"	Loadpcsmatrixfield_sub(fname,wbname,datnm,extn,pathname,nlayer,3,col)	extn="exi"	Loadpcsmatrixfield_sub(fname,wbname,datnm,extn,pathname,nlayer,3,col)	extn="eyi"	Loadpcsmatrixfield_sub(fname,wbname,datnm,extn,pathname,nlayer,3,col)	extn="eyr"	Loadpcsmatrixfield_sub(fname,wbname,datnm,extn,pathname,nlayer,3,col)	extn="ezi"	Loadpcsmatrixfield_sub(fname,wbname,datnm,extn,pathname,nlayer,3,col)	extn="ezr"	Loadpcsmatrixfield_sub(fname,wbname,datnm,extn,pathname,nlayer,3,col)	extn="hxr"	Loadpcsmatrixfield_sub(fname,wbname,datnm,extn,pathname,nlayer,3,col)	extn="hxi"	Loadpcsmatrixfield_sub(fname,wbname,datnm,extn,pathname,nlayer,3,col)	extn="hyi"	Loadpcsmatrixfield_sub(fname,wbname,datnm,extn,pathname,nlayer,3,col)	extn="hyr"	Loadpcsmatrixfield_sub(fname,wbname,datnm,extn,pathname,nlayer,3,col)	extn="hzi"	Loadpcsmatrixfield_sub(fname,wbname,datnm,extn,pathname,nlayer,3,col)	extn="hzr"	Loadpcsmatrixfield_sub(fname,wbname,datnm,extn,pathname,nlayer,3,col)		if(epsload==1)		epswv=wbname+"_eps"		FLoadMatrixWave3D(epswv,"epsilon.dat",pathname,nlayer,2,2,col2)	endif	if(alphaload==1)		alphawv=wbname+"_alpha"		FLoadMatrixWave3D(alphawv,"alpha.dat",pathname,nlayer,2,2,col2)	endif	if(makeCwv==1)		makeCwave0all(wbname,datnm)	endifEnd// scale waves for EM field (3D version)Macro SetScale3Fields(bwname,dx,dy,dz,units,invz)	String bwname	Variable dx,dy,dz,units,invz=2	Prompt bwname,"base wave name"	Prompt dx,"dx"	Prompt dy,"dy"	Prompt dz,"dz"	Prompt units,"units",popup,"m;micron;nm"	Prompt invz,"invert z-axis ?",popup,"yes;no"	PauseUpdate; Silent 1	String unitstr	unitstr=SelectString(units-2,"m","µm","nm")	SetScaleFields3Func(bwname,dx,dy,dz,unitstr,invz)EndFunction SetScaleFields3Func(bwname,dx,dy,dz,unitstr,invz)	String bwname,unitstr	Variable dx,dy,dz,invz		String wlist=WaveList(bwname+"*",";","DIMS:3"),wn	Variable nx,ny,nz,x0,y0,i	wn=StringFromList(0,wlist,";")	if(strlen(wn)==0)		return(1)	endif	nx=DimSize($wn,0)	ny=DimSize($wn,1)	nz=DimSize($wn,2)	i=0	do		wn=StringFromList(i,wlist,";")		if(strlen(wn)==0)			break		endif		SetScale/P x,-(nx-1)/2*dx,dx,unitstr,$wn		SetScale/P y,-(ny-1)/2*dy,dy,unitstr,$wn		if(invz==1)			SetScale/P z,0,-dz,unitstr,$wn		else			SetScale/P z,0,dz,unitstr,$wn		endif		i+=1	while(1)	return(0)End// col: 1: y first, x and z row (older style)// col: 2: x first, y and z row (newer style)Function Loadpcsmatrixfield_sub(fname,wbname,datnm,extnm,pathname,nlayer,dimension,col)	String fname,extnm,pathname,wbname	Variable datnm,nlayer,dimension,col	PauseUpdate;Silent 1		String wname,w0,cmd	Variable ref,col2	if(datnm<0)		fname=fname+"."+extnm		wname=wbname+"_"+extnm	else		sprintf fname,"%s-%d.%s",fname,datnm,extnm		sprintf wname,"%s_%d_%s",wbname,datnm,extnm	endif	if(col==1)		col2=3	else		col2=4	endif		Open/Z=1/R/P=$pathname  ref as fname	if(V_flag==0)		close ref		if(dimension==3)			FLoadMatrixWave3D(wname,fname,pathname,nlayer,2,2,col2)		else //dimension=1			LoadWave/G/M/D/N=dummy/P=$pathName fname			w0=StringFromList(0,S_waveNames,";")			Duplicate/O $w0,$wname		endif	else		close ref		print "filename ",fname, " does not exist."	endifEndMacro pcsmatrix_field_gizmo(wname,wnname)	String wname,wnname	Prompt wname,"wave name",popup,wavelist("*",";","DIMS:3");	Prompt wnname,"Gizmo Window Name"	PauseUpdate;Silent 1		JMGizmoShowXYZSlice(wname,wnname)End// convert complex wavesFunction makeCwave0all(wbname,datnm)	string wbname	Variable datnm		makeCwave(wbname,datnm,"ex")		makeCwave(wbname,datnm,"ey")		makeCwave(wbname,datnm,"ez")		makeCwave(wbname,datnm,"hx")		makeCwave(wbname,datnm,"hy")		makeCwave(wbname,datnm,"hz")	return(0)EndFunction makeCWave0(dest,orig_re,orig_im)	String dest,orig_re,orig_im	Wave re=$orig_re,im=$orig_im	Duplicate/O re,$dest	Wave/C wd=$dest	Redimension/C wd	wd=cmplx(re,im)	return(0)endFunction makeCwave(wbname0,datnm,extn)	String wbname0,extn	Variable datnm	String dest,orig_re,orig_im	String wbname	if(datnm<0)		wbname=wbname0	else		wbname=wbname0+"_"+num2str(datnm)	endif	dest=wbname+"_"+extn	orig_re=wbname+"_"+extn+"r"	orig_im=wbname+"_"+extn+"i"	if((WaveExists($orig_re)==1) && (WaveExists($orig_im))==1)		makeCWave0(dest,orig_re,orig_im)	endif	Return(0)EndFunction product(dest,wv1,wv2)	Wave/C wv1,wv2	String dest	Duplicate/O wv1,$dest	Wave/C dw=$dest	dw=(conj(wv1)*wv2+wv1*conj(wv2))/2	Redimension/R dw	return(dw)End// calculate poyting vectors: real pointying vector should be devided by ZIMP0*(lambda/a) for E_0=1 and epsilon=1Proc poyntingAll(prefix)	String prefix	PauseUpdate; Silent 1	poyntingX(prefix)	poyntingY(prefix)	poyntingZ(prefix)EndProc poyntingX(prefix)	String prefix	PauseUpdate; Silent 1	String ey=prefix+"_ey",ez=prefix+"_ez",hy=prefix+"_hy",hz=prefix+"_hz"	String s="Sx_"+prefix	product("dummy1",$ey,$hz)	product("dummy2",$ez,$hy)	Duplicate/O $ey,$s	$s=(dummy1-dummy2)/2	Redimension/R $sEndProc poyntingY(prefix)	String prefix	PauseUpdate; Silent 1	String ez=prefix+"_ez",ex=prefix+"_ex",hz=prefix+"_hz",hx=prefix+"_hx"	String s="Sy_"+prefix	product("dummy1",$ez,$hx)	product("dummy2",$ex,$hz)	Duplicate/O $ez,$s	$s=(dummy1-dummy2)/2	Redimension/R $sEndProc poyntingZ(prefix)	String prefix	PauseUpdate; Silent 1	String ex=prefix+"_ex",ey=prefix+"_ey",hx=prefix+"_hx",hy=prefix+"_hy"	String sz="Sz_"+prefix	product("dummy1",$ex,$hy)	product("dummy2",$ey,$hx)	Duplicate/O $ex,$sz	$sz=(dummy1-dummy2)/2	Redimension/R $szEnd// Generation: irradience in unit of W/m^2, wavength unit in m, result is 1/cm^3/s (per wavelength bandwidth, to be precise)// it is not necessary to take into account ZIMP0, since in pcsmatrix, poyting vector is obtained for ZIMP0/|E0|^2=1 [1/W]Proc calcGeneration(prefix,irradience,wl,unitl)	String prefix	Variable irradience=1,wl=1e-6,unitl=500e-9	PauseUpdate; Silent 1	String Sx="Sx_"+prefix,Sy="Sy_"+prefix,Sz="Sz_"+prefix	String generation="gen_"+prefix,alphawv=prefix+"_alpha"	Variable ZIMP0=sqrt(4*pi*1e-7/8.854e-12),normal=wl/unitl	poyntingAll(prefix)	Duplicate/O $Sz,$generation	$generation=sqrt($Sx^2+$Sy^2+$Sz^2)*normal*$alphawv*(irradience/(1.2398/wl*1.602e-19))End/// blow are obsolete and not usedProc calcGeneration2(prefix)	String prefix	PauseUpdate; Silent 1	String Sx="Sx_"+prefix,Sy="Sy_"+prefix,Sz="Sz_"+prefix	String Sx2="Sx2_"+prefix,Sy2="Sy2_"+prefix,Sz2="Sz2_"+prefix	String generation="gen_"+prefix	poyntingAll(prefix)//	Differentiate/DIM=0 $Sx/D=$Sx2//	Differentiate/DIM=1 $Sy/D=$Sy2	Differentiate/DIM=2 $Sz/D=$Sz2	Duplicate/O $Sz,$generation	$generation=$Sz2//	$generation=sqrt($Sx2^2+$Sy2^2+$Sz2^2)//	Differentiate/DIM=0 $Sx/D=$Sx2//	Differentiate/DIM=1 $Sy/D=$Sy2//	Differentiate/DIM=2 $Sz/D=$Sz2//	Duplicate/O $Sx,$generation//	$generation=sqrt($Sx2^2+$Sy2^2+$Sz2^2)//*$alphawvEndProc totalFieldIntensity(prefix)	String prefix	PauseUpdate; Silent 1		String exr=prefix+"_exr"	String eyr=prefix+"_eyr"	String ezr=prefix+"_ezr"	String exi=prefix+"_exi"	String eyi=prefix+"_eyi"	String ezi=prefix+"_ezi"	String eps=prefix+"_eps"	String dest="Etot_"+prefix	Duplicate/O $exr,$dest	$dest=$eps*($exr^2+$eyr^2+$ezr^2+$exi^2+$eyi^2+$ezi^2)/2End// I = exp (-alpha*z), dI/dz=-alpha*I alpha=dI/Dz/IProc calcAbsCoef(prefix)	String prefix	PauseUpdate; Silent 1	String Sx="Sx_"+prefix,Sy="Sy_"+prefix,Sz="Sz_"+prefix	String Sx2="Sx2_"+prefix,Sy2="Sy2_"+prefix,Sz2="Sz2_"+prefix	String absCoef="abscoef_"+prefix	poyntingAll(prefix)	Differentiate/DIM=0 $Sx/D=$Sx2; $Sx2=($Sx2/$Sx)	Differentiate/DIM=1 $Sy/D=$Sy2; $Sy2=($Sy2/$Sy)	Differentiate/DIM=2 $Sz/D=$Sz2; $Sz2=($Sz2/$Sz)	Duplicate/O $Sz2,$absCoef//	$absCoef=$Sz2	$AbsCoef=sqrt($Sx2^2+$Sy2^2+$Sz2^2)End//// obsolete procedures end